# -*- coding: utf-8 -*-
"""Task3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1q67L8HvaZ6GLS8ttLT5z7vXTSGe_THu-
"""

import pandas as pd
import numpy as np 
import matplotlib.pyplot as plt
import seaborn as sns
sns.set(style = 'darkgrid')

course_information = pd.read_csv("/content/course_information.csv")
course_posts = pd.read_csv("/content/course_posts.csv")
course_threads = pd.read_csv("/content/course_threads.csv")

course_information.shape, course_posts.shape, course_threads.shape

"""# Figure 1"""

#checking for the missing values
course_information.isnull().sum()

#creating a new dataset with values sorted in a descending order
course_info_sorted =course_information.copy()
course_info_sorted.sort_values(by='num_threads', ascending= False,inplace= True)

#generating plot usinig seaborn
plt.figure(figsize=(10,8))
sns.barplot(data = course_info_sorted, x ='course_id', y = 'num_threads', color='blue');
plt.xticks(rotation = 90, horizontalalignment = 'center');

plt.xlabel("Course Identity")
plt.ylabel("Number of threads")
plt.grid()
plt.tight_layout();
plt.title("Number of threads Vs. Course Identifiers")

"""# Figure 3"""

# Commented out IPython magic to ensure Python compatibility.
# %%time
# #using gorupby to make another dataframe with user_type and post id
# course_posts_1 = course_posts.groupby('user_type')['post_id'].count().reset_index()
# 
# #converting it into a dataframe
# ##course_posts_1 = pd.DataFrame(data = course_posts_1)
# 
# #arranging the data into descending order and using inplace = True to make changes to the dataframe
# course_posts_1.sort_values('post_id', ascending = False, inplace= True)
# 
# #using seaborn to plot 
# sns.barplot(data = course_posts_1, x = 'user_type', y = 'post_id', color = 'blue')
# plt.yscale('log');
# plt.xticks(rotation = 90, horizontalalignment = "center");
# plt.title("Total Number of Messages(log scale) by Coursera user type")
# plt.grid()

"""# Figure 4"""

course_posts.head(2)

#Generating a column where post_id = 0

course_posts['is_post'] = course_posts.parent_id==0

#using groupby.count function to group the variables 

tmp = course_posts.groupby(['course_id', 'thread_id', 'is_post']).count()[['post_id']].reset_index()

# renaming the varibale 'post_id as count

tmp['count'] = tmp['post_id']
tmp.drop('post_id', axis=1, inplace=True)
tmp.head()

#generating a new column with the name num_posts and assigning it value as 0

tmp['num_posts'] = 0

#checking if it's a post if yes replacing it with the value from count

tmp.loc[tmp.is_post == True, 'num_posts'] = tmp['count']
tmp.head()

#if the condition is false inserting values form count to num_comments

tmp['num_comments'] = 0

tmp.loc[tmp.is_post==False, 'num_comments'] = tmp['count']
tmp.head()

#using groupby.max and resetting the index

tmp = tmp.groupby(['course_id', 'thread_id']).max().reset_index()

tmp.head()

#creating a new dataset with values with forum id 4 and 3 and mering it with tmp dataset on course_id and thread_id

fig4_dat = course_threads.query("forum_id == 4|forum_id==3").merge(tmp, on=['course_id', 'thread_id'])
fig4_dat.head(2)

#removing unwanted variables for plotting figure 4

fig4_dat = fig4_dat[['forum_id', 'num_posts', 'num_comments']]
fig4_dat.head(2)

sns.scatterplot(data=fig4_dat, x='num_posts', y='num_comments', hue='forum_id')

#setting limits for x and y axis

plt.xlim(0,100)
plt.ylim(0,100)

#setting labels and the title
plt.xlabel("Number of Posts")
plt.ylabel("Number of Comments")
plt.title("Scatter plot showing relationship between Number of comments and number of posts for Assignments and Study Group");

"""# Figure 2"""

tmp.head()

df = pd.merge( tmp, course_information, on = 'course_id')
df.head(2)

#removing extra variables to generate Figure 2
df = df[['course_id','thread_id', 'count', 'num_posts', 'num_comments','num_users','num_threads', 'weeks']]
df.head(2)

#generating plots
sns.scatterplot(x = df.num_users, y = df.num_threads)

plt.xscale('log')
plt.yscale('log')
plt.xlabel("number of users")
plt.ylabel('number of threads')

"""# Figure 5"""

course_information.head(2)

# creating a new column which tells if the course is Quantitative or not
course_information['Quantitative_courses'] = course_information['type'] == 'Q'

#creating a new df TeMp from course_post
TeMp = course_posts.groupby(['post_id','course_id']).count().reset_index()

#keeping selecteive columns
TeMp = TeMp[['course_id', 'post_id']]

# renaming the column
TeMp['num_of_messages'] = TeMp['post_id']
TeMp.drop('post_id',axis = 1, inplace = True)
TeMp.head()

#Creating a new df using TeMp and Course_information

course_information_with_messages =  pd.merge(TeMp, course_information, on = 'course_id')

#removing extra columns
course_information_with_messages.drop(['name', 'hours', 'start_date', 'end_date', 'language','mandatory_posts'],
                                      axis = 1, inplace = True)

course_information_with_messages.head(2)

#Creating extra columns which we will later use to add values to if they are Quantitative courses

course_information_with_messages['Quant_messages'] = 0
course_information_with_messages['Quant_course_duration'] = 0
course_information_with_messages.head(2)

#Adding number of messages to the Quant_messages column if the course is Quantitative
course_information_with_messages.loc[course_information_with_messages.Quantitative_courses == True
                                     , 'Quant_messages'] = course_information_with_messages['num_of_messages']

##Adding course_duration to the Quant_messages column if the course is Quantitative
course_information_with_messages.loc[course_information_with_messages.Quantitative_courses == True
                                     , 'Quant_course_duration'] = course_information_with_messages['weeks']

#dropping extra columns
course_information_with_messages.head(2)
course_information_with_messages.drop(['type','Quantitative_courses'], axis =1 , inplace = True)

course_information_with_messages.head(2)

#making a column with normalized course duration
course_information_with_messages['normalized_course_duration'] = course_information_with_messages.weeks - course_information_with_messages.weeks.mean() / course_information_with_messages.weeks.std()

#generating a plot
sns.relplot(x = course_information_with_messages.normalized_course_duration, y = course_information_with_messages.Quant_messages, kind = 'line', hue= course_posts.forum_id)